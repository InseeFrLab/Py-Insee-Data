import logging
import os
import re
import time
import urllib3
import warnings

import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

import pynsee
from pynsee.utils._get_credentials import _get_credentials
from pynsee.utils._wait_api_query_limit import _wait_api_query_limit

logger = logging.getLogger(__name__)


class PynseeAPISession(requests.Session):
    """
    Session class used to allow specific timeouts and
    """

    INSEE_API_CODES = {
        # 200:"Opération réussie",
        # 301:"Moved Permanently" -> r.headers['location']
        400: "Bad Request",
        401: "Unauthorized : token missing",
        403: "Forbidden : missing subscription to API",  #
        # 404: "Not Found : no results available",
        406: "Not acceptable : incorrect 'Accept' header",
        413: "Too many results, query must be splitted",
        414: "Request-URI Too Long",
        # Unused (managed through a specific if/else), kept for memory purpose
        # 429: "Too Many Requests : allocated quota overloaded",
        500: "Internal Server Error ",
        503: "Service Unavailable",
    }

    def __init__(
        self,
        http_proxy: str = None,
        https_proxy: str = None,
        sirene_key: str = None,
    ):
        """
        Generates a PynseeAPISession used to perform http(s) requests in pynsee

        If the instance is created without arguments, pynsee will try to get
        variables from environment; if that fails, it will try to retrieve the
        latest config (stored on disk).

        In the other case (with at least one not-None argument), credentials
        stored on disk will be ignored and proxies/sirene key arguments will
        use said arguments.
        **This should only be done through pynsee.utils.init_conn**.

        See pynsee.utils.init_conn to create a new configuration.

        Parameters
        ----------
        http_proxy : str, optional
            HTTP proxy. Use this if working behind a corporate proxy and pynsee
            has not already been configured on the machine. Otherwise, leave
            this to None. The default is None.
        https_proxy : str, optional
            HTTPS proxy. Use this if working behind a corporate proxy and
            pynsee has not already been configured on the machine. Otherwise,
            leave this to None. The default is None.
        sirene_key : str, optional
            Token generated by the API portal. Use this if you wish to access
            the SIRENE API and pynsee has not already been configured. The
            default is None.

        """

        super().__init__()

        # status_forcelist used to be necessary for geodata module
        retry_adapt = Retry(
            total=7, backoff_factor=1, status_forcelist=[429, 502, 503, 504]
        )
        adapter = HTTPAdapter(max_retries=retry_adapt)
        self.mount("https://", adapter)
        self.mount("https://", adapter)

        if any(x is not None for x in (http_proxy, https_proxy, sirene_key)):
            # set credentials for a new pynsee connection
            credentials = {
                "http_proxy": http_proxy,
                "https_proxy": https_proxy,
                "sirene_key": sirene_key,
            }
        else:
            credentials = _get_credentials()

        proxies = {
            "http": credentials.get("http_proxy"),
            "https": credentials.get("https_proxy"),
        }
        self.proxies.update(proxies)

        username = os.environ.get("USERNAME", "username")
        version = pynsee.__version__
        useragent = {"User-Agent": f"python_pynsee_{username}/{version}"}

        # Note : geoplatform seems to impose the "/version" to the user-agent
        self.headers.update(useragent)

        self.sirene_key = credentials.get("sirene_key", None)
        self.headers["X-INSEE-Api-Key-Integration"] = self.sirene_key

    def request(
        self, method, url, timeout=(10, 15), raise_if_not_ok=True, **kwargs
    ):

        logger.info(url)
        with warnings.catch_warnings():
            warnings.simplefilter(
                "ignore", urllib3.exceptions.InsecureRequestWarning
            )
            response = super().request(method, url, timeout=timeout, **kwargs)
            if raise_if_not_ok and not response.ok:
                raise requests.exceptions.RequestException(
                    f"response was {response.status_code} for {url}",
                    response=response,
                )
        return response

    def request_insee(
        self,
        api_url=None,
        sdmx_url=None,
        file_format="application/xml",
        print_msg=True,
        raise_if_not_ok=False,
    ):
        "Performs a query to insee, either through API or sdmx_url"
        result = None

        try:
            if api_url and self._query_is_valid_sirene_call(api_url):
                if not self.sirene_key:
                    commands = "\n\ninit_conn(sirene_key='my_sirene_key')\n"
                    msg = (
                        "Sirene key is missing, please check your credentials "
                        "on portail-api.insee.fr !\n"
                        "Please do the following to use your "
                        f"credentials: {commands}\n\n"
                        "If your token still does not work, please try to "
                        "clear the cache :\n "
                        "from pynsee.utils import clear_all_cache;"
                        " clear_all_cache()\n"
                    )
                    raise ValueError(msg)

                self._set_sirene_key()

            if api_url:
                result = self._request_api_insee(
                    api_url,
                    file_format=file_format,
                    raise_if_not_ok=raise_if_not_ok,
                    print_msg=print_msg,
                )

        except ValueError as e:

            if self._query_is_valid_sirene_call(api_url):
                # Log the error as a SIRENE API call can not function without
                # key
                logger.critical(e)

        except requests.exceptions.RequestException:
            if sdmx_url:
                if print_msg:
                    logger.critical("SDMX web service used instead of API")
                result = self._request_sdmx_insee(
                    sdmx_url, raise_if_not_ok=raise_if_not_ok
                )

        return result

    def _query_is_valid_sirene_call(self, url):
        "check if an URL is a valid API call to SIRENE"
        return re.match(".*api-sirene.*", url)

    def _set_sirene_key(self):

        sirene_key = _get_credentials().get("sirene_key", None)
        if not sirene_key:
            raise ValueError
        self.headers["X-INSEE-Api-Key-Integration"] = sirene_key

    def _request_sdmx_insee(self, url, raise_if_not_ok=True):
        results = self.get(url, verify=False)
        if raise_if_not_ok and not results.ok:
            raise requests.exceptions.RequestException(
                results.text + "\n" + url, response=results
            )
        return results

    def _request_api_insee(
        self,
        url,
        file_format="application/xml",
        raise_if_not_ok=False,
        print_msg=True,
    ):

        headers = {"Accept": file_format}

        # avoid reaching the limit of 30 queries per minute from insee api
        if self._query_is_valid_sirene_call(url):
            _wait_api_query_limit(url)

        try:
            results = self.get(
                url,
                headers=headers,
                verify=False,
                raise_if_not_ok=raise_if_not_ok,
            )
        except Exception:
            results = None
            success = False
        else:

            code = results.status_code

            if "status_code" not in dir(results):
                success = False
            elif code == 429:

                if (
                    os.environ.get(
                        "PYNSEE_DISPLAY_ALL_WARNINGS", "false"
                    ).lower()
                    == "true"
                ):
                    msg = (
                        "API query number limit reached - "
                        "function might be slowed down"
                    )
                    logger.warning(msg)

                time.sleep(10)

                request_again = self._request_api_insee(
                    url=url, file_format=file_format
                )

                return request_again

            elif code in self.INSEE_API_CODES and raise_if_not_ok:
                msg = (
                    f"Error {code} - {self.INSEE_API_CODES[code]}\n"
                    f"Query:\n{url}"
                )
                raise requests.exceptions.RequestException(
                    msg, response=results
                )
            elif code not in (200, 404) and raise_if_not_ok:
                # Note : 404 means no results from API, this should not trigger
                # any exception
                success = False
            else:
                success = True

        if success is True:
            return results

        else:

            try:
                results = results.text
            except Exception:
                results = ""

            if print_msg:
                msg = (
                    "An error occurred !\n"
                    f"Query : {url}\nResults : {results}\n"
                    "Make sure you have subscribed to all APIs !\n"
                    "Click on all APIs' icons one by one, select your "
                    "application, and click on Subscribe"
                )

                logger.warning(msg)
            raise requests.exceptions.RequestException(
                "Une erreur est survenue", response=results
            )


# if __name__ == "__main__":
#     s = PynseeAPISession()
#     url = "https://api.insee.fr/series/BDM/V1/data/SERIES_BDM/001688370"
#     r = s.get(url)
#     print(r)
